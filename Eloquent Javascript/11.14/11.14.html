<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <div>
        创建正则表达式 正则表达式是一种对象类型。我们可以使用两种方法来构造正则表达式：一是使用 RegExp 构 造器构造一个正则表达式对象；二是使用斜杠（ / ）字符将模式包围起来，生成一个字面 值。let re1 = new RegExp("abc"); let re2 = /abc/; 这两个正则表达式对象都表示相同的模式：字符 a 后紧跟一个 b ，接着紧跟一个 c 。 使用 RegExp 构造器时，需要将模式书写成普通的字符串，因此反斜杠的使用规则与往常相 同。第二种写法将模式写在斜杠之间，处理反斜杠的方式与第一种方法略有差别。首先，由于斜 杠会结束整个模式，因此模式中包含斜杠时，需在斜杠前加上反斜杠。此外，如果反斜杠不 是特殊字符代码（比如 \n ）的一部分，则会保留反斜杠，不像字符串中会将其忽略，也不会 改变模式的含义。一些字符，比如问号、加号在正则表达式中有特殊含义，如果你想要表示 其字符本身，需要在字符前加上反斜杠。 let eighteenPlus = /eighteen\+/; 匹配测试 正则表达式对象有许多方法。其中最简单的就是 test 方法。 test 方法接受用户传递的字符 串，并返回一个布尔值，表示字符串中是否包含能与表达式模式匹配的字符串。 console.log(/abc/.test("abcde")); // → true console.log(/abc/.test("abxde")); // → false 不包含特殊字符的正则表达式简单地表示一个字符序列。如果使用 test 测试字符串时，字符 串中某处出现 abc （不一定在开头），则返回 true 。 字符集 我们也可调用 indexOf 来找出字符串中是否包含 abc 。正则表达式允许我们表达一些更复杂 的模式。 124
九、正则表达式 假如我们想匹配任意数字。在正则表达式中，我们可以将一组字符放在两个方括号之间，该 表达式可以匹配方括号中的任意字符。 下面两个表达式都可以匹配包含数字的字符串。 console.log(/[0123456789]/.test("in 1992")); // → true console.log(/[0-9]/.test("in 1992")); // → true 我们可以在方括号中的两个字符间插入连字符（ – ），来指定一个字符范围，范围内的字符 顺序由字符 Unicode 代码决定。在 Unicode 字符顺序中，0 到 9 是从左到右彼此相邻的（代 码从48到57），因此 [0-9] 覆盖了这一范围内的所有字符，也就是说可以匹配任意数字。 许多常见字符组都有自己的内置简写。 数字就是其中之一： \ d 与 [0-9] 表示相同的东西。 \d 任意数字符号 \w 字母和数字符号（单词符号） \s 任意空白符号（空格，制表符，换行符等类似符号） \D 非数字符号 \W 非字母和数字符号 \S 非空白符号 . 除了换行符以外的任意符号 因此你可以使用下面的表达式匹配类似于 30-01-2003 15:20 这样的日期数字格式： let dateTime = /\d\d-\d\d-\d\d\d\d \d\d:\d\d/; console.log(dateTime.test("30-01-2003 15:20")); // → true console.log(dateTime.test("30-jan-2003 15:20")); // → false 这个表达式看起来是不是非常糟糕？该表达式中一半都是反斜杠，影响读者的理解，使得读 者难以揣摩表达式实际想要表达的模式。稍后我们会看到一个稍加改进的版本。 我们也可以将这些反斜杠代码用在方括号中。例如， [\d.] 匹配任意数字或一个句号。但是 方括号中的句号会失去其特殊含义。其他特殊字符也是如此，比如 + 。 你可以在左方括号后添加脱字符（ ^ ）来排除某个字符集，即表示不匹配这组字符中的任何 字符。 125
九、正则表达式 let notBinary = /[^01]/; console.log(notBinary.test("1100100010100110")); // → false console.log(notBinary.test("1100100010200110")); // → true 部分模式重复 现在我们已经知道如何匹配一个数字。如果我们想匹配一个整数（一个或多个数字的序 列），该如何处理呢？ 在正则表达式某个元素后面添加一个加号（ + ），表示该元素至少重复一次。因此 /\d+/ 可 以匹配一个或多个数字字符。 console.log(/'\d+'/.test("'123'")); // → true console.log(/'\d+'/.test("''")); // → false console.log(/'\d*'/.test("'123'")); // → true console.log(/'\d*'/.test("''")); // → true 星号（ * ）拥有类似含义，但是可以匹配模式不存在的情况。在正则表达式的元素后添加星 号并不会导致正则表达式停止匹配该元素后面的字符。只有正则表达式无法找到可以匹配的 文本时才会考虑匹配该元素从未出现的情况。 元素后面跟一个问号表示这部分模式“可选”，即模式可能出现 0 次或 1 次。下面的例子可以匹 配 neighbour （ u 出现1次），也可以匹配 neighbor （ u 没有出现）。 let neighbor = /neighbou?r/; console.log(neighbor.test("neighbour")); // → true console.log(neighbor.test("neighbor")); // → true 我们可以使用花括号准确指明某个模式的出现次数。例如，在某个元素后加上 {4} ，则该模 式需要出现且只能出现 4 次。也可以使用花括号指定一个范围：比如 {2,4} 表示该元素至少 出现 2 次，至多出现 4 次。 这里给出另一个版本的正则表达式，可以匹配日期、月份、小时，每个数字都可以是一位或 两位数字。这种形式更易于解释。 let dateTime = /\d{1,2}-\d{1,2}-\d{4} \d{1,2}:\d{2}/; console.log(dateTime.test("30-1-2003 8:45")); // → true 花括号中也可以省略逗号任意一侧的数字，表示不限制这一侧的数量。因此 {,5} 表示 0 到 5 次，而 {5,} 表示至少五次。 126
    </div>
</body>
<style>
    
</style>
<script>
    
</script>
</html>